<!DOCTYPE html>
<html lang="ko">
<head>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>역학적 에너지 보존: 운석 격추 게임</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at 60% 40%, #0f2027 0%, #2c5364 100%);
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            font-size: 80%;
            color: #e0f7fa;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: transparent;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #statsPanel {
            position: absolute;
            top: 24px;
            left: 32px;
            background: rgba(20,30,50,0.92);
            color: #00eaff;
            padding: 16px 20px;
            border-radius: 16px;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            z-index: 20;
            min-width: 150px;
            max-width: 170px;
            box-shadow: 0 2px 16px #00eaff44, 0 1px 8px #0008;
            border: 1.5px solid #00eaff88;
            backdrop-filter: blur(6px);
            font-size: 1em;
        }
        #statsPanel b {
            color: #00ffd0;
            font-weight: 700;
            text-shadow: 0 0 6px #00ffd0;
        }
        #uiPanel {
            position: absolute;
            top: 100px;
            left: 32px;
            background: rgba(20,30,50,0.96);
            color: #e0f7fa;
            padding: 28px 20px 32px 20px;
            border-radius: 18px;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            z-index: 15;
            min-width: 150px;
            max-width: 170px;
            min-height: 420px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            box-shadow: 0 2px 16px #00eaff33, 0 1px 8px #0008;
            border: 1.5px solid #00eaff88;
            backdrop-filter: blur(6px);
            font-size: 1em;
        }
        #uiPanel button {
            background: linear-gradient(90deg, #00eaff 0%, #0055ff 100%);
            color: #fff;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            box-shadow: 0 2px 12px #00eaff44;
            letter-spacing: 1px;
            cursor: pointer;
            margin-bottom: 10px;
            font-size: 1.18em;
            padding: 10px 28px;
            transition: background 0.2s, box-shadow 0.2s;
        }
        #uiPanel button:hover {
            background: linear-gradient(90deg, #00ffd0 0%, #0055ff 100%);
            box-shadow: 0 4px 24px #00eaff88;
        }
        #uiPanel input, #uiPanel select {
            font-family: inherit;
            font-size: 1em;
            border-radius: 7px;
            border: 1.2px solid #00eaff88;
            background: #101c2c;
            color: #00eaff;
            margin: 8px 0 12px 0;
            padding: 8px 10px;
            outline: none;
            transition: border 0.2s;
            width: 100%;
            box-sizing: border-box;
        }
        #uiPanel input:focus, #uiPanel select:focus {
            border: 1.5px solid #00ffd0;
            background: #162a3a;
        }
        #uiPanel form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }
        #meteorInfo {
            margin-bottom: 14px;
            color: #00ffd0;
            font-size: 1.05em;
            letter-spacing: 0.5px;
            text-align: left;
        }
        #shotResult {
            color: #ff2e88;
            font-weight: bold;
            margin-top: 12px;
            text-shadow: 0 0 8px #ff2e88aa;
            font-size: 1em;
            min-height: 24px;
        }
        #shotQueuePanel {
            position: absolute;
            top: 32px;
            right: 40px;
            background: rgba(20,30,50,0.92);
            color: #00eaff;
            padding: 16px 18px;
            border-radius: 16px;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            z-index: 10;
            min-width: 170px;
            max-width: 200px;
            box-shadow: 0 4px 24px #00eaff22, 0 1px 8px #0008;
            border: 1.5px solid #00eaff88;
            backdrop-filter: blur(6px);
            font-size: 0.98em;
        }
        #shotQueuePanel h3 {
            margin: 0 0 8px 0;
            font-size: 1.08em;
            color: #00ffd0;
            letter-spacing: 1px;
            font-weight: 700;
            text-shadow: 0 0 8px #00ffd0;
        }
        #shotQueueList {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #shotQueueList li {
            margin-bottom: 8px;
            background: linear-gradient(90deg, #101c2c 0%, #162a3a 100%);
            border-radius: 8px;
            padding: 7px 10px;
            font-size: 0.98em;
            color: #00eaff;
            border: 1px solid #00eaff44;
            box-shadow: 0 1px 6px #00eaff22;
        }
        #shotQueueList li b {
            color: #ff2e88;
            text-shadow: 0 0 6px #ff2e88aa;
        }
        label, span {
            color: #e0f7fa;
            font-size: 1em;
            margin-right: 8px;
        }
        form button[type="submit"] {
            background: linear-gradient(90deg, #00eaff 0%, #0055ff 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 7px 18px;
            font-size: 1em;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px #00eaff44;
            margin-left: 0;
            margin-top: 8px;
            transition: background 0.2s, box-shadow 0.2s;
        }
        form button[type="submit"]:hover {
            background: linear-gradient(90deg, #00ffd0 0%, #0055ff 100%);
            box-shadow: 0 4px 16px #00eaff88;
        }
        /* 역학적 에너지 체크박스 및 문구 통일 스타일 */
        .energy-check-wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 4px;
        }
        .energy-check-wrap input[type="checkbox"] {
            accent-color: #00eaff;
            width: 18px;
            height: 18px;
            margin-bottom: 4px;
        }
        .energy-check-wrap span {
            font-size: 1em;
            color: #00eaff;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="statsPanel">
        <div id="successCount">격추 성공: <b>0</b></div>
        <div id="failCount">격추 실패: <b>0</b></div>
    </div>
    <div id="uiPanel">
        <button id="startBtn">게임 시작</button>
        <div id="meteorInfo">운석을 클릭해 정보를 확인하세요.</div>
        <form id="shotForm" autocomplete="off">
            <label>격추 고도:
                <select id="inputAltitude">
                    <option value="200">고고도 (200m)</option>
                    <option value="150">중고도 (150m)</option>
                    <option value="100">저고도 (100m)</option>
                </select>
            </label>
            <label>운석 속력(m/s): <input type="number" id="inputVelocity" step="1"></label>
            <button type="submit">대포 발사 예약</button>
        </form>
        <div class="energy-check-wrap">
            <input type="checkbox" id="energyCheck">
            <span>역학적 에너지 표시</span>
        </div>
        <div id="shotResult"></div>
    </div>
    <div id="shotQueuePanel">
        <h3>대포 발사 대기열</h3>
        <ul id="shotQueueList"></ul>
    </div>
    <script>
    // ====== 상수 및 설정 ======
    const GRAVITY = 9.8; // m/s²
    const METEOR_SPAWN_ACCEL = 0.97;
    const METEOR_SPAWN_MIN_INTERVAL = 800;
    const MAX_METEOR_COUNT = 3;
    const CANNONBALL_SPEED = 500; // m/s
    const DT_SCALE = 0.1; // 시간 흐름 배속(1/10)

    // ====== 캔버스 및 UI 요소 ======
    const canvas = document.getElementById('gameCanvas');
    // devicePixelRatio 적용
    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
        ctx.scale(dpr, dpr);
        earthRadius = Math.min(window.innerWidth, window.innerHeight) * 0.03;
        earthX = window.innerWidth / 2;
        earthY = window.innerHeight / 2;
        // 운석 생성 고도(300m) 픽셀 변환
        meteorSpawnAltitude = (300 / 200) * earthRadius * 12; // 300m 고정, 기존 200m 기준에서 1.5배
    }
    const ctx = canvas.getContext('2d');
    const meteorInfo = document.getElementById('meteorInfo');
    const shotForm = document.getElementById('shotForm');
    const inputAltitude = document.getElementById('inputAltitude');
    const inputVelocity = document.getElementById('inputVelocity');
    const shotResult = document.getElementById('shotResult');
    const startBtn = document.getElementById('startBtn');
    const shotQueueList = document.getElementById('shotQueueList');
    const energyCheck = document.getElementById('energyCheck');

    // ====== 게임 상태 변수 ======
    let meteors = [];
    let selectedMeteor = null;
    let gameStarted = false;
    let meteorSpawnInterval = 3000;
    let meteorSpawnTimer = 0;
    let successCount = 0;
    let failCount = 0;
    // 격추/실패 이펙트 관리
    let effects = [];

    // ====== 지구 및 운석 위치/크기 계산 ======
    let earthRadius, earthX, earthY, meteorSpawnAltitude;
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // 드롭다운 선택 고도값(미터) 관리
    let selectedAltitude = parseInt(inputAltitude.value);
    inputAltitude.addEventListener('change', function() {
        selectedAltitude = parseInt(this.value);
    });

    // ====== Meteor 클래스 ======
    class Meteor {
        constructor(angle, altitude, size, velocity) {
            this.angle = angle;
            this.altitude = altitude;
            this.size = size;
            this.velocity = velocity;
            this.active = true;
            this.shotReserved = false;
            this.shotAltitude = null;
            this.shotVelocity = null;
            this.shotTime = null;
            this.shotResult = null;
            this.cannonballActive = false;
            this.cannonballPos = null;
            this.cannonballStart = null;
            this.cannonballEnd = null;
            this.cannonballStartTime = null;
            this.cannonballDuration = null;
        }
        update(dt) {
            if (!this.active) return;
            this.velocity += GRAVITY * dt;
            this.altitude -= this.velocity * dt;
            // 운석이 지구에 충돌한 경우(격추 실패)
            if (this.altitude <= earthRadius) {
                this.active = false;
                // 격추 실패 집계 및 이펙트 (운석 실제 충돌 위치, 지속시간 증가)
                failCount++;
                updateStatsPanel();
                const {x, y} = this.getScreenPos();
                effects.push({
                    x: x,
                    y: y,
                    color: "rgba(255,46,136,0.25)",
                    border: "#ff2e88",
                    radius: earthRadius * 0.5,
                    alpha: 1,
                    time: performance.now(),
                    duration: 1500 // ms
                });
            }
        }
        getScreenPos() {
            const x = earthX + Math.cos(this.angle) * this.altitude;
            const y = earthY + Math.sin(this.angle) * this.altitude;
            return {x, y};
        }
        draw(ctx, selected) {
            if (!this.active) return;
            const {x, y} = this.getScreenPos();
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, this.size * earthRadius * 0.015, 0, 2 * Math.PI); // 본체 크기 1.5배
            ctx.fillStyle = "#fff";
            ctx.fill();
            drawMeteorArrow(ctx, earthX, earthY, x, y, this.size * earthRadius * 0.15); // 화살표 크기 1.5배
            if (selected) {
                ctx.beginPath();
                ctx.arc(x, y, this.size * earthRadius * 0.195, 0, 2 * Math.PI); // 선택 외곽선 1.5배
                ctx.strokeStyle = "#ff2222";
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(x, y, this.size * earthRadius * 0.27, 0, 2 * Math.PI); // 선택 외곽선 1.5배
                ctx.strokeStyle = "#ff2222";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            if (this.velocity > 0) {
                const {x: tailX, y: tailY} = {
                    x: x + Math.cos(this.angle) * this.velocity * 3, // 꼬리 길이 1.5배
                    y: y + Math.sin(this.angle) * this.velocity * 3
                };
                ctx.save();
                const grad = ctx.createLinearGradient(x, y, tailX, tailY);
                grad.addColorStop(0, "#ff2e88");
                grad.addColorStop(1, "rgba(0,238,255,0)");
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(tailX, tailY);
                ctx.strokeStyle = grad;
                ctx.lineWidth = this.size * earthRadius * 0.03; // 꼬리 두께 1.5배
                ctx.shadowColor = "#ff2e88";
                ctx.shadowBlur = 18;
                ctx.stroke();
                ctx.restore();
            }
            // 운석 본체 (크기 2배 -> 1.5배로 조정)
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, this.size * earthRadius * 0.03, 0, 2 * Math.PI); // 본체 크기 1.5배
            ctx.fillStyle = "#ff2e88";
            ctx.shadowColor = "#ff2e88";
            ctx.shadowBlur = 27;
            ctx.fill();
            ctx.restore();
        }
    }

    // ====== 운석 생성 방향 벡터(화살표) 그리기 ======
    function drawMeteorArrow(ctx, x0, y0, x1, y1, meteorRadius) {
        // 운석 방향 벡터
        const dx = x1 - x0;
        const dy = y1 - y0;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len < 1e-6) return;
        // 지구 외곽선에서 10px 떨어진 지점에서 시작
        const startOffset = 10;
        const startX = x0 + dx * ((earthRadius + startOffset) / len);
        const startY = y0 + dy * ((earthRadius + startOffset) / len);
        // 운석 방향으로 10px 길이 화살표
        const arrowLen = 10;
        const arrowEndX = startX + dx * (arrowLen / len);
        const arrowEndY = startY + dy * (arrowLen / len);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(arrowEndX, arrowEndY);
        ctx.strokeStyle = '#00ffd0';
        ctx.lineWidth = 3.5;
        ctx.shadowColor = '#00ffd0';
        ctx.shadowBlur = 10;
        ctx.stroke();
        // 화살촉
        const headlen = 10;
        const angle = Math.atan2(dy, dx);
        ctx.beginPath();
        ctx.moveTo(arrowEndX, arrowEndY);
        ctx.lineTo(arrowEndX - headlen * Math.cos(angle - Math.PI/7), arrowEndY - headlen * Math.sin(angle - Math.PI/7));
        ctx.lineTo(arrowEndX - headlen * Math.cos(angle + Math.PI/7), arrowEndY - headlen * Math.sin(angle + Math.PI/7));
        ctx.lineTo(arrowEndX, arrowEndY);
        ctx.fillStyle = '#00ffd0';
        ctx.shadowColor = '#00ffd0';
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.restore();
    }
    function updateStatsPanel() {
        document.getElementById('successCount').innerHTML = `격추 성공: <b>${successCount}</b>`;
        document.getElementById('failCount').innerHTML = `격추 실패: <b>${failCount}</b>`;
    }
    updateStatsPanel();
    // ====== 운석 생성 ======
    function spawnMeteor() {
        if (meteors.filter(m => m.active).length >= MAX_METEOR_COUNT) return;
        const angle = Math.random() * 2 * Math.PI;
        const altitude = meteorSpawnAltitude;
        const size = 3 + Math.random() * 2;
        const velocity = Math.random() * 30; // 초기 속력 범위 0~30으로 증가
        meteors.push(new Meteor(angle, altitude, size, velocity));
    }

    // ====== 운석 클릭 선택 ======
    // 터치/마우스 이벤트 모두 지원
    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches && e.touches.length > 0) {
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        } else {
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
    }
    function handleMeteorSelect(e) {
        if (!gameStarted) return;
        const {x: mx, y: my} = getPointerPos(e);
        selectedMeteor = null;
        for (const meteor of meteors) {
            if (!meteor.active) continue;
            const {x, y} = meteor.getScreenPos();
            const r = meteor.size * earthRadius * 0.13;
            if ((mx-x)**2 + (my-y)**2 < r*r) {
                selectedMeteor = meteor;
                break;
            }
        }
        updateMeteorInfo();
    }
    canvas.addEventListener('mousedown', handleMeteorSelect);
    canvas.addEventListener('touchstart', function(e) {
        handleMeteorSelect(e);
        e.preventDefault();
    }, {passive: false});

    // ====== UI 정보 갱신 ======
    let showEnergy = false;
    energyCheck.checked = false;
    energyCheck.addEventListener('change', function() {
        showEnergy = this.checked;
        updateMeteorInfo();
    });
    function updateMeteorInfo() {
        if (!selectedMeteor || !selectedMeteor.active) {
            meteorInfo.textContent = "운석을 클릭해 정보를 확인하세요.";
            inputVelocity.value = "";
            shotResult.textContent = "";
            return;
        }
        let infoHtml =
            `현재 고도: <b>${Math.round(selectedMeteor.altitude)}</b> m<br>` +
            `현재 속력: <b>${Math.round(selectedMeteor.velocity)}</b> m/s`;
        if (showEnergy) {
            // 역학적 에너지 계산: E = mgh + 0.5mv^2, m=1kg 가정
            const m = 1;
            const h = selectedMeteor.altitude;
            const v = selectedMeteor.velocity;
            let E = m * GRAVITY * h + 0.5 * m * v * v;
            E = Math.round(E * 10) / 10; // 소수점 첫째 자리까지
            infoHtml += `<br>역학적E: <b>${E}</b> J/kg`;
        }
        meteorInfo.innerHTML = infoHtml;
        inputVelocity.value = "";
        shotResult.textContent = "";
    }

    // ====== 대포 발사 예약 ======
    shotForm.addEventListener('submit', handleShotReserve);
    function handleShotReserve(e) {
        e.preventDefault();
        if (!selectedMeteor || !selectedMeteor.active) return;
        const shotAltitude = selectedAltitude;
        const shotVelocity = parseInt(inputVelocity.value);
        if (isNaN(shotAltitude) || isNaN(shotVelocity)) return;
        if (shotAltitude > selectedMeteor.altitude) {
            shotResult.textContent = "현재 운석 고도보다 격추 고도가 높습니다.";
            return;
        }
        // 예약 시점의 운석 고도/속력 사용
        const meteorAltitude = selectedMeteor.altitude;
        const meteorVelocity = selectedMeteor.velocity;
        selectedMeteor.shotReserved = true;
        selectedMeteor.shotAltitude = shotAltitude;
        selectedMeteor.shotVelocity = shotVelocity;
        // 등가속도 공식 계산 (수식은 사용자 편집 유지)
        const a = GRAVITY;
        const b = meteorVelocity;
        const c = meteorAltitude - shotAltitude;
        let tMeteor = 0;
        tMeteor = (-b + Math.sqrt(b*b + 2*a*c)) / a;
        if (!isFinite(tMeteor) || tMeteor < 0) tMeteor = 0;
        tMeteor /= DT_SCALE;
        // 대포알 이동 시간 계산 (배속 적용X)
        const cannonballDistance = meteorAltitude;
        const cannonballDuration = cannonballDistance / CANNONBALL_SPEED;
        let fireDelay = tMeteor - cannonballDuration;
        if (fireDelay < 0) fireDelay = 0;
        selectedMeteor.cannonballFireTime = performance.now() + fireDelay * 1000;
        selectedMeteor.shotTime = performance.now() + tMeteor * 1000;
        shotResult.textContent = `대포 발사가 예약되었습니다.\n운석 도달 예상 시간: ${tMeteor.toFixed(2)}초\n대포알 발사까지 남은 시간: ${fireDelay.toFixed(2)}초`;
        selectedMeteor.cannonballActive = false;
        selectedMeteor.cannonballStart = null;
        selectedMeteor.cannonballEnd = null;
        selectedMeteor.cannonballStartTime = null;
        selectedMeteor.cannonballDuration = cannonballDuration * 1000;
        selectedMeteor.cannonballPos = null;
    }

    // ====== 격추 체크 및 대포알 모션 ======
    function checkShot(meteor) {
        if (!meteor.shotReserved || !meteor.active) return;
        const now = performance.now();
        if (!meteor.cannonballActive && meteor.shotReserved && now >= meteor.cannonballFireTime) {
            meteor.cannonballActive = true;
            meteor.cannonballStart = { x: earthX, y: earthY };
            const { x, y } = meteor.getScreenPos();
            meteor.cannonballEnd = { x, y };
            meteor.cannonballStartTime = now;
            if (!meteor.cannonballDuration) {
                const dist = Math.sqrt((x-earthX)**2 + (y-earthY)**2);
                meteor.cannonballDuration = (dist / CANNONBALL_SPEED) / DT_SCALE * 1000;
            }
            meteor.cannonballPos = { x: earthX, y: earthY };
        }
        if (meteor.cannonballActive && meteor.cannonballDuration > 0) {
            let progress = Math.min(1, (now - meteor.cannonballStartTime) / meteor.cannonballDuration);
            meteor.cannonballPos = {
                x: meteor.cannonballStart.x + (meteor.cannonballEnd.x - meteor.cannonballStart.x) * progress,
                y: meteor.cannonballStart.y + (meteor.cannonballEnd.y - meteor.cannonballStart.y) * progress
            };
            if (progress >= 1) {
                const actualAltitude = Math.round(meteor.altitude);
                const actualVelocity = Math.round(meteor.velocity);
                const inputAltitude = Math.round(meteor.shotAltitude);
                const inputVelocity = Math.round(meteor.shotVelocity);
                // 판정: 고도는 정확히 일치, 속력은 +-1까지 허용
                const shotSuccess =
                    actualAltitude === inputAltitude &&
                    Math.abs(actualVelocity - inputVelocity) <= 1;
                meteor.shotResult = shotSuccess ? "운석 격추 성공!" : "격추 실패! (정확한 값 입력 필요)";
                meteor.shotReserved = false;
                meteor.cannonballActive = false;

                // 격추 성공 카운트 및 UI 갱신 (실패는 운석 충돌 시 집계)
                if (shotSuccess) {
                    meteor.active = false;
                    successCount++;
                    updateStatsPanel();
                }

                if (meteor === selectedMeteor) shotResult.textContent = meteor.shotResult;

                // 파괴 이펙트 추가 (예시)
                effects.push({
                    x: meteor.cannonballPos.x,
                    y: meteor.cannonballPos.y,
                    color: shotSuccess ? "rgba(0,238,255,0.35)" : "rgba(255,46,136,0.35)",
                    border: shotSuccess ? "#00eaff" : "#ff2e88",
                    radius: earthRadius * 0.42,
                    alpha: 1,
                    time: performance.now(),
                    duration: 700 // ms
                });
            }
        }
    }

    // ====== 게임 루프 ======
    let lastTime = null;
    function gameLoop(ts) {
        if (!lastTime) lastTime = ts;
        const dt = ((ts - lastTime) / 1000) * DT_SCALE;
        lastTime = ts;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawEarth();
        // 선택한 격추 고도에 붉은색 점선 동심원 표시(고도값을 픽셀로 변환)
        if (selectedAltitude) {
            drawAltitudeCircle(selectedAltitude);
        }
        // 이펙트 렌더링 (파괴 이펙트)
        const now = performance.now();
        effects = effects.filter(eff => {
            const elapsed = now - eff.time;
            if (elapsed > eff.duration) return false;
            const fade = 1 - (elapsed / eff.duration);
            ctx.save();
            ctx.globalAlpha = eff.alpha * fade;
            ctx.beginPath();
            ctx.arc(eff.x, eff.y, eff.radius, 0, 2 * Math.PI);
            ctx.fillStyle = eff.color;
            ctx.shadowColor = eff.border;
            ctx.shadowBlur = 24;
            ctx.fill();
            ctx.restore();
            return true;
        });
        meteors.forEach(meteor => {
            meteor.update(dt);
            meteor.draw(ctx, meteor === selectedMeteor);
            checkShot(meteor);
            if (meteor.cannonballActive && meteor.cannonballPos) {
                drawCannonball(meteor.cannonballPos.x, meteor.cannonballPos.y);
            }
        });
        if (gameStarted) handleMeteorSpawning(dt);
        updateShotQueueUI();
        requestAnimationFrame(gameLoop);
    }

    // ====== 대포알 그리기 ======
    function drawCannonball(x, y) {
    // 대포알 궤적(혜성꼬리)
    ctx.save();
    if (typeof drawCannonball.lastPos === 'object') {
        const grad = ctx.createLinearGradient(drawCannonball.lastPos.x, drawCannonball.lastPos.y, x, y);
        grad.addColorStop(0, "#00eaff");
        grad.addColorStop(1, "rgba(0,238,255,0)");
        ctx.beginPath();
        ctx.moveTo(drawCannonball.lastPos.x, drawCannonball.lastPos.y);
        ctx.lineTo(x, y);
        ctx.strokeStyle = grad;
        ctx.lineWidth = earthRadius * 0.09;
        ctx.shadowColor = "#00eaff";
        ctx.shadowBlur = 12;
        ctx.stroke();
    }
    drawCannonball.lastPos = {x, y};
    // 대포알 본체 (크기 확대)
    ctx.beginPath();
    ctx.arc(x, y, earthRadius * 0.14, 0, 2 * Math.PI);
    ctx.fillStyle = "#00eaff";
    ctx.shadowColor = "#00eaff";
    ctx.shadowBlur = 18;
    ctx.fill();
    ctx.restore();
}

    // ====== 대포 발사 대기열 UI 갱신 ======
    function updateShotQueueUI() {
        const queue = meteors.filter(m => m.shotReserved && m.active);
        shotQueueList.innerHTML = '';
        if (queue.length === 0) {
            shotQueueList.innerHTML = '<li>대기 중인 발사 없음</li>';
            return;
        }
        queue.forEach((meteor, idx) => {
            const remain = Math.max(0, Math.round((meteor.shotTime - performance.now()) / 1000));
            const fireRemain = Math.max(0, Math.round((meteor.cannonballFireTime - performance.now()) / 1000));
            shotQueueList.innerHTML += `<li>운석 #${meteors.indexOf(meteor)+1} | 고도: ${meteor.shotAltitude}m | 속력: ${meteor.shotVelocity}m/s <br>운석 도달 예상: <b>${remain}</b>초<br>대포알 발사까지: <b>${fireRemain}</b>초</li>`;
        });
    }

    // ====== 지구 그리기 ======
    function drawEarth() {
        // 네온 지구 본체
        ctx.save();
        ctx.beginPath();
        ctx.arc(earthX, earthY, earthRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "#00eaff";
        ctx.shadowColor = "#00eaff";
        ctx.shadowBlur = 32;
        ctx.fill();
        ctx.restore();
        // 운석 생성 고도(300m) 푸른 외곽선 동심원
        ctx.save();
        ctx.beginPath();
        ctx.arc(earthX, earthY, meteorSpawnAltitude, 0, 2 * Math.PI);
        ctx.strokeStyle = "#00ffd0";
        ctx.lineWidth = 2.5;
        ctx.setLineDash([12, 12]);
        ctx.shadowColor = "#00ffd0";
        ctx.shadowBlur = 16;
        ctx.stroke();
        ctx.restore();
    }
    // 선택한 격추 고도에 붉은색 점선 동심원 표시 함수
    function drawAltitudeCircle(altitude) {
        // 고도(m)를 픽셀로 변환: 1m = meteorSpawnAltitude/300(px)
        // meteorSpawnAltitude는 300m에 해당하는 픽셀값
        let radiusPx = (altitude / 300) * meteorSpawnAltitude;
        ctx.save();
        ctx.beginPath();
        ctx.arc(earthX, earthY, radiusPx, 0, 2 * Math.PI);
        ctx.strokeStyle = "#ff2e88";
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 10]);
        ctx.shadowColor = "#ff2e88";
        ctx.shadowBlur = 12;
        ctx.globalAlpha = 0.7;
        ctx.stroke();
        ctx.restore();
    }

    // ====== 운석 생성 및 타이머 관리 ======
    function handleMeteorSpawning(dt) {
        meteorSpawnTimer += dt * 1000;
        if (meteorSpawnTimer >= meteorSpawnInterval) {
            if (meteors.filter(m => m.active).length < MAX_METEOR_COUNT) spawnMeteor();
            meteorSpawnTimer = 0;
            meteorSpawnInterval = Math.max(METEOR_SPAWN_MIN_INTERVAL, meteorSpawnInterval * METEOR_SPAWN_ACCEL);
        }
        if (meteors.every(m => !m.active)) {
            meteors = [];
            spawnMeteor();
            meteorSpawnInterval = 3000;
        }
    }

    // ====== 게임 시작 버튼 이벤트 ======
    startBtn.addEventListener('click', startGame);
    function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        meteors = [];
        selectedMeteor = null;
        meteorSpawnInterval = 3000;
        meteorSpawnTimer = 0;
        spawnMeteor();
        updateMeteorInfo();
        startBtn.style.display = "none";
    }

    // ====== 최초 UI 정보 갱신 및 게임 루프 시작 ======
    updateMeteorInfo();
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
